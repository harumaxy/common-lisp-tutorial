# データの読み書き

外の世界と通信するにはインターフェースが必要


# テキスト表示 & 読み込み

- print

```lisp
(print "a")

"a"
"a"
(print 1)

1
1
```
REPL は二回 "a" を返す。
print 自体の評価値は、表示した値と同じ

# print & read

何かを表示したいときは print
何かを読み込みたいときは read

をまず考えるようにする

# コンピュータの立場

print と read はコンピュータの立場で考える

"aaaa" -> string
1 -> int
とわかるので、クオートなしでも読み書きする


すなわち、`read` で読み込んだのが Lisp のデータ型になるなら、 string -> ? への明示的なキャストが必要ない

生のテキストデータを Lisp のデータに変換できる

# 文字リテラル

`#\` という記号を置くと文字になる
`#\a` `#\b` ...


# princ vs print

- print
  - 出力するデータ型を動的に判断して出力
  - 読み戻して、元のデータ型に戻せる。
    - 代償として、任意の文字列を出力することができない
      - "aaaa" だったら、ダブルクオートが外せない(文字列型)
      - `\`を出力できない (エスケープだから)

- princ
  - 思いのままに情報を出力できる
    - 人間に読みやすいが、コンピュータがデータ構造に読み戻せない
    - 対称性が破られる

# Lisp コード と Lispデータ の対称性

print, read を使うと
生のテキストデータ -> Lisp データに変換できることがわかった

つまり、プログラムコードとデータは同じように扱える
同図象性(homoiconic) ホモイコニック

コードモードとデータモードを使い分けてきたのを見ればわかるように、
Lispコード自体がLispデータにできる

`(+ 1 2)` というコードをデータにしたければ `'(+ 1 2)`
ただ、データにしたコードをもとに戻して実行するには？

# eval 関数

```lisp
(defparameter *foo* '(+ 1 2))
(eval *foo*)
```
変数に、データモードで格納した Lisp コードを実行するのが `eval`

つまり、実行中に外部から読み込んだテキストデータをコードとして実行できる。
自己書き換えプログラムも書けるので、AIマニアに愛されていた時代もある

経験豊富な Lisper は eval を使わないらしい。
なぜなら eval はおそろしくて強力なので、使い所が難しいから。

Lisp マクロを使えばすむ場面が多い



# 超絶簡単な自分専用REPLの作り方

```lisp
(defun game-repl ()
  (loop (print (eval (read)))))

; (look)
```
まさしく、 read -> eval -> print -> loop
4つの関数だけ使ってる

read でよみ、eval で評価し、 print で値を出力
loop は無限ループするだけ


この動作をカスタマイズしたければ、それぞれの関数を自分で定義したものに置き換える

# game-read

```lisp
... flet ((quote-it (x) (list 'quote x))) ...
```

シンボルをquote するには、 (quote symbol) のコンスを作ればいい

# game-eval

ゲームをハッキングから守るため、決められたコマンドだけを eval するようにする



