# Lisp is Sicence

Lisp は計算機科学の世界の研究で、複雑な問題を解くのに役立っている。
実は、プログラミングができるのは副次的なメリットに過ぎない

# 関数型プログラミングでレベルアップ

Haskeller と Lisper は対立してる？
Haskell 共和国で副作用を使うと
副作用使用罪で処刑される。

副作用を多用するコード = 黒魔術


# What is functional programming?

大雑把に言えば関数だけでコードを組み立てるスタイル

ここで言う「関数」とは数学者の言う関数と全く同じ意味を指す


- 受け取れる値の集まり : 定義域
- 戻り値の集まり : 値域

ベテランLisper 的には、関数が戻り値を返すというのを好まない人がいる。
「関数が〜という値を返す」 より、 「関数が〜という値へ評価される」という言い回しを好む


ラムダ算法に使ったプログラムは、プログラム実行により最初の表記から式を置換していって、
最終的に置換できなくなった状態を関数の結果とする。

自分に取って自然な方を選べばいい


# 数学における関数

数学的な関数の性質
- 参照透過性
  - 同じ引数には同じ結果を返す (純粋関数)
- 外部の変数を絶対に参照しない
  - つまり、グローバル変数を使わないってこと
- 目的は引数から値を計算することだけ
- 外の世界に影響を与えないこと
  - スクリーン表示、音を出すとか
- 外の世界の情報を受け取らない、キーボードやディスクを呼んだりしない

可能な限り、これらのルールに従ってプログラムを書けば
関数型プログラミングスタイル。

数学関数は、rand とか以外は純粋関数

例 (sin 0.5)


# 限界
すべてコードを関数型スタイルで書くことは不可能

スクリーンに出力、スピーカーに出力
などをするとき、副作用を持つという

主作用 = 渡された引数使って関数を評価すること
副作用 = それ以外のこと、音を鳴らす、スクリーン表示、ファイル入出力、キーボードの入力取得、ネットワーク通信




# 命令的プログラミング
副作用を持つコードは汚いとされる (数学的なコンテキストでは)
これをコンピューターサイエンス的には「命令的」(operative) という

具体的に言えば、コンピューターのコードが手順書のスタイルになっているから
1. あれをせよ
2. これをせよ
3. 変数xに値を入れろ
4. スクリーンに出力しろ
5. ...


## 関数型プログラミングの中心原理

- 最初の大部分は関数型プログラミングスタイルで書く。ここには副作用を含めず清浄にする。
- 最後の少しの部分だけ、すべての副作用を含んで外の世界との交渉を担う。この部分だけ不浄を許し、なるべく小さく保つ

汚い部分ときれいな部分は分けようという話

きれいな部分はテストしやすく、品質を保ちやすい
清浄:不浄は 8:2 くらいが望ましい。

なお、`小さいソフトウェア`では、不浄な部分の割合の方が大きくなりやすい
(不浄な部分は必須なため)

# Higher Order Programming

一つの動作を完了するために、どうやってコードの断片を組み立てたらいいかわからない関数型プログラミング初心者の問題がよくある。

## コードの合成
プログラミング言語は、コードの合成がやりやすいように設計されていなければならない

コードの合成の意味するところはそのまま

命令的
- for loop + add 2 (上書き)

関数型
- map + add 2 (新しいコピー)

## 高階プログラミング
関数型プログラミングにおいて、最も強力なコード合成
関数を引数にする関数を作ること
(関数を返す関数は実は Higher Order じゃない？)

# operative vs functional

list `'(4 7 2 3)` の各要素に、 +2 する

```lisp
(defparameter *my-list* '(4 7 2 3))

(loop for n below (length *my-list*)
  do (setf (nth n *my-list*) (+ (nth n *my-list*) 2)))
```

C とか Java でやりそうなのは、loop & setf のコンボ
きれいではないがメリットも有る
- 新しいリストを allocate せず、古いリストに上書きするのでメモリ効率がいい
  - array を使えば更に早い

デメリット
- 元のリストを破壊している(上書き)
  - 他のところでもグローバル変数である `*my-list*`を使っているとすると、知らない間に内容が変更されているということになりやすい
  - ↑ を「`プログラムに隠された状態がある`」という
- ループの回数を記録する n (カウンタ変数)を一時的に用意しないといけない
  - 変数が増えるとコードが膨らむ、バグが忍び込む余地が増える
  - n に不正な値を入れたりするとバグる

## functional style

``lisp
(defun add-two (list)
  (when list
    (cons (+ 2 (car list)) (add-two (cdr list)))))
```
再帰呼び出しでループする

ただし、コードの合成という意味ではちょっと渾然一体している。
高階関数を使うことで、独立した部品にすることができる。


## helping by higher order function

```lisp
(mapcar (lambda (x) (+ x 2))  '(4 7 2 3))
```

- `mapcar`がループ
- `lambda`が処理

を担当する。コードの合成が簡単にできていて、lambda の部分を変えれば他の処理にできる。

# Why functional programming is Crazy?

##  関数型プログラミングは副作用を起こせない -> 現実には何もできないのと同じ
  - エスケープハッチとして、命令的な汚い副作用コードを少しの場所にまとめることにした

##  ものすごく非効率なプログラムになり得る
- すでにあるデータを破壊せず、新しい状態に下コピーを作らねばならない
  - 大量のメモリ確保とコピーにより、ものすごく遅くなる
    - 部分構造を共有することで解決できる場合もある(要は defstruct と、 struct 参照渡し)

- ループを再帰呼び出しで実現すること
  - プログラムスタックをたくさん積まねばならず、実行の足を引っ張る
  - ただし、これらは性能問題の大部分を解決できる最適化技術により問題ない場合が多い
    - メモカ
    - 末尾再帰最適化
    - 遅延評価
    - 高階プログラミング

- 純粋関数スタイルが合わないタイプのソフトウェアもある
  - Oracle DB など、Relational data base
  - 性能がすごく大事なプログラム(1msレイテンシが命取りとか)
    - DB に関しては、小さなオンメモリDBなら実用になりうる (Haskell の HAooS-IxSet)



# Whay functional programming is Great?

## バグを減らす
隠された状態が少ない
よって、プログラマが期待した振る舞いを逸脱しない。

エラーも予測しやすく、バグの再現もしやすい
(参照透過性により、同じ引数なら何回でも同じふるまい)

## 関数型スタイルは簡潔

- 見やすいプログラム
- Higher Order Function を使って、一時変数を減らせる
- 小さな関数にたくさん分ける

命令的プログラミングの大量の変数宣言がだいぶ減る


##　関数型スタイルはエレガント

コンピュータープログラムを数学の領域に戻してくれる

数学と同じレベルの純粋さのコードは、数学の式と同じくエレガント
数学の概念やツールも適用しやすくなる。

# まとめ
- 関数型スタイルは参照透過性
- 命令形プログラミングは、「あれをして」「これをして」といった手順書じみている
- Lisp で関数型プログラミングをするなら、純粋関数の部分と非純粋関数の部分にわけて 8:2 くらいにする。
- 関数型プログラミングは、素早くて簡潔でバグが少ない


